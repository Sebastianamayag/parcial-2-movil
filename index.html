<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    
    <script type="text/javascript" src="../libs/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"
        integrity="sha512-LF8ZB1iTwi4Qvkm4pekHG4a437Y9Af5ZuwbnW4GTbAWQeR2E4KW8WF+xH8b9psevV7wIlDMx1MH9YfPqgKhA/Q=="
        crossorigin="anonymous"></script>
    <script src = "https://stemkoski.github.io/Three.js/js/THREEx.KeyboardState.js"></script>
    <script type="text/javascript" src="../libs/physi.js"></script>
    <script type="text/javascript" src="../libs/dat.gui.js"></script>
    <script type="text/javascript" src="../libs/chroma.js"></script>
    <script>
        Physijs.scripts.worker = '../libs/physijs_worker.js';
        Physijs.scripts.ammo = '../libs/ammo.js';
        var stats;
        var scene, camera, render;
        var updateFcts	= [];
        var cube;
        var cube2;
        var rebote=false,rebote2=false;
        var s,s2;

        function createCamera() {
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                1,
                100
            );
            camera.position.set(0, 0, 20);
            camera.lookAt(new THREE.Vector3(0, 0, 20));
        }
        function createRenderer() {
            renderer = new THREE.WebGLRenderer();
            renderer.shadowMapEnabled = true;
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(new THREE.Color(0xffffff));
            document.body.appendChild(renderer.domElement);
        }

        function createPlane() { 
            var planeGeometry = new THREE.PlaneGeometry(50, 25, 1, 1); 
            var planeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 }); 
            var plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.position.set(0,0,0); 
            scene.add(plane); 
        }
        
        function createCube1() { 
            let planeGeometry = new THREE.BoxGeometry(6, 1, 1); 
            cube = new Physijs.BoxMesh(planeGeometry);
            cube.position.set(0,-11,0); 
            scene.add(cube);
            cube.castShadow = true;
            let constraint = new Physijs.SliderConstraint(cube, new THREE.Vector3(0, -110, 0), new THREE.Vector3(0, 1, 0));
            scene.addConstraint(constraint);
            /*constraint.setLimits(-10, 10, 10, -10);
            constraint.setRestitution(0,0);*/
        }
        function createCube2() { 
            var planeGeometry = new THREE.BoxGeometry(6, 1, 1); 
            var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); 
            cube2 = new THREE.Mesh(planeGeometry, planeMaterial);
            cube2.position.set(0,11,0); 
            scene.add(cube2); 
        }

        function createballoon() { 
            let planeGeometry1 = new THREE.SphereGeometry(1, 10, 10);  
            s = new Physijs.SphereMesh(planeGeometry1);
            s.position.set(0,0,0); 
            s.castShadow = true;
            scene.add(s); 
            let constraint = new Physijs.PointConstraint(s,s,s.position);
            scene.addConstraint(constraint);
        }

        function init() {
            //create scene
            createCamera();
            scene = new Physijs.Scene({reportSize: 10, fixedTimeStep: 1 / 60});
            createPlane();
            createCube1();
            createCube2();
            createballoon();
            createRenderer();
            var keyboard = new THREEx.KeyboardState(renderer.domElement);
            updateFcts.push(function (delta, now) {
                if (keyboard.pressed('left')) {
                    cube.position.x -= 0.5 ;
                } else if (keyboard.pressed('right')) {
                    cube.position.x += 0.5 ;
                }
            })
            //element render
        }
            init();
            updateFcts.push(function(){
                renderer.render( scene, camera );	
                
            })

            var lastTimeMsec = null
                requestAnimationFrame(function animate(nowMsec) {
                    	
                    if(cube2.position.x<20 && !rebote){
                        cube2.position.x +=0.5;
                    }
                    if(cube2.position.x==19.5){
                        rebote=true;
                    }
                    if(cube2.position.x>-20 && rebote){
                        cube2.position.x -=0.5;
                    }
                    if(cube2.position.x==-19.5){
                        rebote=false;
                    }   
                    // keep looping
                    requestAnimationFrame(animate);
                    scene.simulate();
                    // measure time
                    lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
                    var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
                    lastTimeMsec = nowMsec
                    // call each update function
                    updateFcts.forEach(function (updateFn) {
                        updateFn(deltaMsec / 1000, nowMsec / 1000)
                    })
                    
                })
            

        


    </script>
</body>

</html>